# functions for geometry operations (geoops)

import numpy as np
import os 
from scipy.spatial.transform import Rotation as R
from rdkit import Chem

import gauops as gps
import processing as pro

def write_grid(args):
    '''
    Function for generating a grid of displacements, handling calls to create_grid
    and writing to .gjf, .sh and .zip files as needed.
    '''
    outpath = pro.get_output_filename(args.out, args.inp, args.inp2)
        
    os.makedirs(outpath, exist_ok=True)
    file_plus_path = outpath + '\\' + outpath

    res_xyz = [args.res[0], args.res[0], args.res[0]]   # if 1 res passed, x=y=z
    if len(args.res) > 1:                               # if 2 res passed, y=z
        res_xyz[1] = res_xyz[2] = args.res[1]
    if len(args.res) > 2:                               # if 3 passed, x!=y!=z
        res_xyz[2] = args.res[2]

    if args.est:
        args.x, args.y, args.z = estimate_grid_from_glog(args.inp, dx = args.est_x, dy = args.est_y, dz = args.est_z)          # here, estimate the x/y/z ranges from the input file using estimate_grid_from_glog.
        
    grid = gen_grid(x = args.x, y = args.y, z = args.z, res_xyz = res_xyz, min_disp = args.min_dist)     # get a grid using the user supplied spacings.
    
    rot_angles = [args.xa, args.ya, args.za]
    
    outname, count =  create_grid(args.inp, grid = grid, groute = args.groute, rot_angs = rot_angles, nproc = args.cpu, vmem = args.mem,  min_max_dist = [args.min_dist, args.max_dist], filename2 = args.inp2, outname = file_plus_path)
    
    gps.make_sge_job(dir_path = outpath, file = outpath, nproc = args.cpu, vmem = args.mem, startjob=1, endjob=count) # make the SGE job
    
    if args.zip: # bundle into .zip for unleashing on HPC (quicker to upload one file than 100k small ones)
        pro.zip_files(dir_path = outpath, zip_file = outpath, ext =('gjf','sh'))
    
def create_grid(filename, grid, nproc = 4, vmem = 4, groute = '#T', rot_angs = [0,0,0], min_max_dist =[2,7], count = 1, filename2 = None, outname = None):                
    '''                                                                                                                   
    Function to create a grid of points which we use as translation vectors for our second molecule                       
    For each point on the grid we offset molecule 2 by this much, allowing us to scan across all 3 dimensions             
                                                                                                                          
    Args:                                                                                                                 
        filename  - base geometry as .log file from Gaussian (optimised!)
        grid      - grid generated by gen_grid()
        groute    - Gaussian route section for bimolecular PES calculations. 

        rot_angs  - rotate by x=[0], y = [1] and z=[2] degrees

        min_max_dist - mix ([0]) and max ([1]) distances used as cutoffs for atoms in mol2; bimolecular pairs with atoms outside these limits are rejected.
        
        count     - a counter used for writing the right number of SGE files (default = 1)
    
        filename2 - Can supply a different molecule for the second one to "scan" w.r.t. the first
    Returns:
        gjf files - Gaussian input files, one for each accepted set of translations
        sh file   - SGE file for executing on ARC3/4
        
    '''
    
    outname = pro.get_output_filename(outname, filename, filename2)
       
    gps.clean_path(outname) # tidy directory
    
    geometry = frag2_geometry = generate_coords(gps.get_geometries(filename)[-1]) # have both geometries the same for now, update below

    if (filename2 != None) | ((filename2 != filename) & (filename2 != None)):
        frag2_geometry = generate_coords(gps.get_geometries(filename2)[-1])
        
    if (np.abs(rot_angs[0]) + np.abs(rot_angs[1]) + np.abs(rot_angs[2])) != 0:
        frag2_geometry = rotate_coordinates(geometry,  x_angle=rot_angs[0], y_angle=rot_angs[1], z_angle=rot_angs[2])

    frag1 = add_fragment_label(geometry,1)
    
    for gri in grid:
        frag2 = add_fragment_label(translate_coordinates(frag2_geometry, dx=gri[0], dy=gri[1], dz=gri[2]), 2)

        if not check_fragments_too_close(frag1, frag2, min_cutoff=min_max_dist[0]):
            if not check_fragments_too_far(frag1, frag2, max_cutoff=min_max_dist[1]):
                displacement = f'dx={gri[0]}/dy={gri[1]}/dz={gri[2]}/'
                file_name = outname + '_' + str(count)
                gps.write_gjf(frag1, frag2, displacement=displacement, groute = groute, nproc = nproc, vmem = vmem, file_name=file_name)
                count += 1
    print(f'A total of {count-1} geometries written after min_dist={min_max_dist[0]} and max_dist={min_max_dist[1]} spatial cutoffs')
    
    return outname, count
    


def estimate_grid_from_glog(filename, dx = 0, dy = 0, dz = 0):
    '''
    Reads a gaussian output file (glog; filename) and estimate a reasonable set of x/y/z displacements as the floor/ceiling of the min/max x/y/z values
    
    Args:
        filename: the gaussian output file from which we'll read and parse geometry
        dx/dy/dz: additional user requested displacement in X/Y/Z, respectively. Coded to be symmetric (could improve that easily)
    
    Returns:
        Tuple containing displacements suitable for the parse_dimension function called in bimolpes.py
    '''
    print(f'Estimating displacements based on final geometry of {filename}')
    geometry = generate_coords(gps.get_geometries(filename)[-1])
    
    min_x = min_y = min_z = float('inf')    # Initialize minimums to infinity
    max_x = max_y = max_z = -float('inf')   # Initialize maxima to negative infinity
    
    for line in geometry:
        parts = line.split()
        atom_vdw_radii = Chem.GetPeriodicTable().GetRvdw(parts[0])  # get VdW radii of the atom
        x, y, z = map(float, parts[1:4])
        
        min_x = np.floor(min(min_x, 2 * (x - (atom_vdw_radii + dx)))) # take displacements as 2x +/- vwd radii and additional user requested displacemenet (dx/y/z)
        min_y = np.floor(min(min_y, 2 * (y - (atom_vdw_radii + dy))))
        min_z = np.floor(min(min_z, 2 * (z - (atom_vdw_radii + dz))))
        max_x = np.ceil(max(max_x,  2 * (x + (atom_vdw_radii + dx))))
        max_y = np.ceil(max(max_y,  2 * (y + (atom_vdw_radii + dy))))
        max_z = np.ceil(max(max_z,  2 * (z + (atom_vdw_radii + dz))))
    
    return ((min_x, max_x), (min_y, max_y), (min_z, max_z))
    
def generate_coords(extracted_geometry):
    '''
    takes extracted geometry from get_geometries and polishes it so we can reuse it in a new input .gjf file
    
    Args:
        extracted_geometry  - our extracted geometry (just a single geometry!) from get_geometries.
    
    Returns
        coords              - .gjf formatted coordinates.
    '''
    
    lines = extracted_geometry.strip().split('\n')
    data_lines = lines[5:-1]    # Skipping header and footer lines

    atomic_data = []
    coords = []                 # empty array for coordinate data

    for line in data_lines:     # Extract atomic number, element symbol, and coordinates
        columns = line.split()
        atomic_number = int(columns[1])
        element_symbol = Chem.GetPeriodicTable().GetElementSymbol(atomic_number)
        x, y, z = float(columns[3]), float(columns[4]), float(columns[5])
        atomic_data.append((element_symbol, x, y, z))


    for symbol, x, y, z in atomic_data:    # store the extracted data
        coords.append(f"{symbol}         {x} {y} {z}")
        
    return(coords)
	
def gen_grid(x, y, z, res_xyz = [1, 1, 1], min_disp = None):
    """
    Make a grid that spans =dx to +dx in steps of res
    
    Args:
        x,y,z       - tuple; min/max x-value (and y, z)
        res_x/y/z   - resolution; set x/y/z seperately 
    Returns:
        grid    - grid of points used as translation coordinates
    """
        
    x_range = np.arange(x[0], x[1] + res_xyz[0], res_xyz[0])
    y_range = np.arange(y[0], y[1] + res_xyz[1], res_xyz[1])
    z_range = np.arange(z[0], z[1] + res_xyz[2], res_xyz[2])

    grid = []
    count = 0
    for x_ in x_range:
        for y_ in y_range:
            for z_ in z_range:
                if (min_disp is None) or (np.sqrt(x_**2 + y_**2 + z_**2) >= min_disp):
                    grid.append((x_, y_, z_))
                    count += 1
    print(f'\nA total of {np.product(np.shape(grid)) - count} grid points rejected at first pass due to close contact (min_dist={min_disp})')
    print(f'Using a grid of x={x} y={y} z={z} with resolutions (res_x={res_xyz[0]}, res_y={res_xyz[1]}, res_z={res_xyz[2]}); Final grid size={np.product(np.shape(grid))}\n')
    
    
    return grid

def add_fragment_label(geometry, fragment_number=1):
    """
    Adds "(Fragment={fragment_number})" after the atomic symbol in each line of the geometry.
    
    Args:
        geometry: List of strings representing the atoms and their coordinates.
    
    Returns:
        Updated geometry with "(Fragment=1)" labels as a list of strings.
    """
    updated_geometry = []

    for line in geometry:
        parts = line.split()
        if len(parts) == 4:
            atom, x, y, z = parts[0], parts[1], parts[2], parts[3]
            atom_with_fragment = f"{atom}(Fragment={fragment_number})"
            new_line = f"{atom_with_fragment} {x} {y} {z}"
            updated_geometry.append(new_line)

    return updated_geometry


def translate_coordinates(geometry, dx=0, dy=0, dz=0):
    """
    Adjusts the geometry by adding/subtracting deltas to the x, y, and z coordinates.
    
    Args:
        geometry: List of strings representing the atoms and their coordinates.
        dx: Value to add/subtract from the x coordinate.
        dy: Value to add/subtract from the y coordinate.
        dz: Value to add/subtract from the z coordinate.
    
    Returns:
        adjusted_geometry - Adjusted geometry as a list of strings.
    """
    adjusted_geometry = []

    for line in geometry:
        parts = line.split()
        if len(parts) == 4:
            atom, x, y, z = parts[0], float(parts[1]), float(parts[2]), float(parts[3])
            x_new = x + dx
            y_new = y + dy
            z_new = z + dz
            new_line = f"{atom} {x_new:.6f} {y_new:.6f} {z_new:.6f}"
            adjusted_geometry.append(new_line)

    return adjusted_geometry


def rotate_coordinates(coordinates, x_angle=0, y_angle=0, z_angle=0):
    '''
    Rotate coordinates by applying a rotation matrix. Takes raw geometry from get_geometry
    Args:
        coordinates - geometry from get_geometry function
        x_angle     - x_angle to rotate by, in degrees
        y_angle     - y_angle to rotate by, in degrees
        z_angle     - z_angle to rotate by, in degrees
        
    Returns:
        adjusted_geometry - the input geometry rotated by user supplied angle(s).
    '''
    print(f'Rotating fragment by: x={x_angle}, y={y_angle}, z={z_angle}')
    
    x_rad = np.radians(x_angle)
    y_rad = np.radians(y_angle)
    z_rad = np.radians(z_angle)

    rotation = R.from_euler('xyz', [x_angle, y_angle, z_angle], degrees=True) # rot matrix from SciPy Euler for brevity
    adjusted_geometry = []

    for line in coordinates:
        parts = line.split()
        if len(parts) == 4:
            atom, x, y, z = parts[0], float(parts[1]), float(parts[2]), float(parts[3])
            original_coords = np.array([x, y, z])
            new_coords = np.dot(R, original_coords)
            new_line = f"{atom}    {new_coords[0]:.6f} {new_coords[1]:.6f} {new_coords[2]:.6f}"
            adjusted_geometry.append(new_line)

    return adjusted_geometry

def distance(point1, point2):
    """
    Calculate the distance between two points in xyz.
    """
    return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2 + (point1[2] - point2[2]) ** 2) ** 0.5

def check_fragments_too_close(frag1, frag2, min_cutoff=2):
    """
    Check if any atoms in two fragments are too close based on the cutoff distance.

    Args:
        frag1 (list): The list of atoms and their coordinates for the first fragment.
        frag2 (list): The list of atoms and their coordinates for the second fragment.
        cutoff (float): The cutoff distance to consider atoms too close.

    Returns:
        bool: True if any atoms are too close, False otherwise.
    """
    for atom1 in frag1:
        for atom2 in frag2:
            coords1 = tuple(map(float, atom1.split()[1:4]))
            coords2 = tuple(map(float, atom2.split()[1:4]))
            if distance(coords1, coords2) < min_cutoff:
                return True
    return False

def check_fragments_too_far(frag1, frag2, max_cutoff=5):
    """
    Check if any atoms in two fragments are too close based on the cutoff distance.

    Args:
        frag1 (list): The list of atoms and their coordinates for the first fragment.
        frag2 (list): The list of atoms and their coordinates for the second fragment.
        cutoff (float): The cutoff distance to consider atoms too close.

    Returns:
        bool: True if any atoms are too close, False otherwise.
    """
    for atom1 in frag1:
        for atom2 in frag2:
            coords1 = tuple(map(float, atom1.split()[1:4]))
            coords2 = tuple(map(float, atom2.split()[1:4]))
            if distance(coords1, coords2) <= max_cutoff:
                return False 
    return True  
